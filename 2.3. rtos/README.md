## Лабораторная работа 2.3. RTOS на примере FreeRTOS
### Цель работы
Познакомиться с RTOS используя в качестве примерера FreeRTOS

# RTOS Fundamentals

## Введение

**RTOS (Real-Time Operating System)** — это тип операционной системы, спроектированный для детерминированного и быстрого реагирования на события. RTOS часто используются в **встроенных системах**, таких как медицинские приборы или автомобильные ЭБУ, где требуется своевременная обработка внешних событий.  

RTOS обычно меньше и легче, чем ОС общего назначения, поэтому подходят для устройств с ограниченной памятью, вычислительными ресурсами и энергопотреблением.

---

## Многозадачность

**Ядро (Kernel)** — основной компонент операционной системы.  
В FreeRTOS потоки называются **tasks (задачи)**. В отличие от ОС общего назначения, здесь нет разделения на процессы и потоки — только задачи.  

### Преимущества многозадачности

- Позволяет разбить сложное приложение на множество более простых задач.  
- Облегчает тестирование, совместную работу и повторное использование кода.  
- RTOS берёт на себя сложное управление временем и последовательностью выполнения.

### Многозадачность vs Параллелизм

На однопроцессорной системе **одновременно выполняется только одна задача**, но RTOS быстро переключает задачи, создавая эффект одновременного выполнения (concurrency).

---

## Планирование задач

**Scheduler** — часть ядра, которая выбирает, какая задача будет выполняться в конкретный момент времени.  

- Задача может быть **приостановлена** (`suspended`) и **возобновлена** (`resumed`).  
- Задача может **сдаваться** (`yield`) или **задерживаться** (`sleep/delay`) через API FreeRTOS.  

Пример:

```c
// Приостановка задачи
vTaskSuspend(taskHandle);

// Возобновление задачи
vTaskResume(taskHandle);

// Задержка выполнения задачи на 500 мс
vTaskDelay(pdMS_TO_TICKS(500));
```
Теперь предположим, что система реального времени также выполняет управляющую функцию, которая зависит от цифрового фильтра. Входные данные должны быть выборочно сняты, отфильтрованы и обработаны в управляющем цикле каждые 2 мс. Для корректной работы фильтра регулярность выборки должна быть точной с точностью до 0,5 мс.

Эта функциональность может быть реализована как автономная задача со следующей структурой:

```c
void vControlTask( void *pvParameters )
{
    for( ;; )
    {
        [Delay waiting for 2ms since the start of the previous cycle]
        [Sample the input]
        [Filter the sampled input]
        [Perform control algorithm]
        [Output result]
    }
}
```

# Распределение приоритетов задач в RTOS

Инженер-программист должен назначить задаче управления **высший приоритет**, так как:

- Срок выполнения задачи управления более строгий, чем у задачи обработки нажатия клавиши.
- Последствия пропуска дедлайна для задачи управления более серьёзны, чем для задачи обработки клавиши.

Ниже приведена схема, демонстрирующая, как эти задачи будут планироваться **операционной системой реального времени (RTOS)**. RTOS создала собственную задачу — **idle task**, которая выполняется только тогда, когда нет других задач, готовых к выполнению. Idle task всегда находится в состоянии, когда может выполняться.

![RTExample](RTExample.gif)

## Хронология событий

1. **Начало:** Ни одна из наших двух задач не может выполняться:  
   - `vControlTask` ожидает правильного времени для начала нового цикла управления.  
   - `vKeyHandlerTask` ожидает нажатия клавиши.  
   **Процессорное время выделяется idle task.**

2. **Время t1:** Происходит нажатие клавиши.  
   - `vKeyHandlerTask` теперь может выполняться.  
   - Так как она имеет более высокий приоритет, чем idle task, ей выделяется процессорное время.

3. **Время t2:** `vKeyHandlerTask` завершила обработку клавиши и обновление LCD.  
   - Она не может продолжать до следующего нажатия клавиши, поэтому приостанавливается.  
   - RTOS возобновляет выполнение idle task.

4. **Время t3:** Срабатывает таймер, сигнализируя о начале нового цикла управления.  
   - `vControlTask` теперь может выполняться.  
   - Как задача с наивысшим приоритетом, она получает процессорное время **немедленно**.

5. **Между t3 и t4:** Происходит нажатие клавиши.  
   - `vKeyHandlerTask` готова к выполнению, но так как её приоритет ниже `vControlTask`, она **не получает процессорного времени**.

6. **Время t4:** `vControlTask` завершает цикл управления и приостанавливается.  
   - `vKeyHandlerTask` теперь является задачей с наивысшим приоритетом, готовой к выполнению, и ей выделяется процессорное время для обработки нажатия клавиши.

7. **Время t5:** Обработка нажатия клавиши завершена, `vKeyHandlerTask` приостанавливается до следующего события клавиши.  
   - Ни одна из наших задач не готова к выполнению, поэтому RTOS планирует idle task.

8. **Между t5 и t6:** Обрабатывается таймерное событие, но новых нажатий клавиш не происходит.

9. **Время t6:** Происходит новое нажатие клавиши.  
   - До завершения обработки нажатия срабатывает таймер.  
   - Обе задачи готовы к выполнению.  
   - Так как `vControlTask` имеет более высокий приоритет, `vKeyHandlerTask` приостанавливается, а `vControlTask` получает процессорное время.

10. **Время t8:** `vControlTask` завершает цикл управления и приостанавливается.  
    - `vKeyHandlerTask` снова является задачей с наивысшим приоритетом для выполнения, и обработка нажатия клавиши завершается.



# Потоки на ESP32

На **ESP32** потоки реализуются через **FreeRTOS**, встроенную операционную систему реального времени (RTOS), которая идёт в составе ESP-IDF. В терминах FreeRTOS потоки называются **tasks (задачи)**.  

## Основные принципы

- **Задачи (Tasks)** — отдельные потоки выполнения, которые могут работать параллельно.  
- Каждая задача имеет:
  - **стек** (память для локальных переменных и работы функции),  
  - **приоритет**,  
  - **состояние** (готова, выполняется, блокирована).  
- **FreeRTOS Scheduler** управляет переключением задач, реализуя кооперативную и приоритетную многозадачность.  

> ESP32 имеет два ядра Xtensa, поэтому задачи могут выполняться параллельно на двух ядрах, если закрепить их за разными ядрами.

## Создание задачи

`xTaskCreate(task_function, "Task Name", stack_size, parameters, priority, &task_handle);`

- `task_function` — функция задачи.  
- `"Task Name"` — имя задачи (для отладки).  
- `stack_size` — размер стека в байтах.  
- `parameters` — параметры, передаваемые в задачу.  
- `priority` — приоритет задачи.  
- `task_handle` — хендл задачи (можно использовать для управления задачей).  

## Планирование и приоритет

- Задачи с **высоким приоритетом** выполняются раньше задач с низким приоритетом.  
- Задачи с одинаковым приоритетом используют **round-robin** планирование.  
- Задача может быть **заблокирована** через `vTaskDelay()` или другие механизмы FreeRTOS, освобождая CPU для других задач.  

## Многопоточность на двух ядрах

ESP32 имеет два ядра (**PRO_CPU (0)** и **APP_CPU (1)**).  
- `xTaskCreatePinnedToCore()` позволяет закрепить задачу за конкретным ядром.  
- Если ядро не указано, задача может выполняться на любом ядре.

## Важные моменты

- Каждой задаче нужен достаточный стек, иначе возможен `stack overflow`.  
- Приоритеты задач влияют на планирование: слишком высокий приоритет одной задачи может заблокировать остальные.  
- Для совместного доступа к ресурсам используют **Mutex**, **Semaphore**, **Queue**.  
- FreeRTOS предоставляет множество функций для управления задачами и обмена данными.

Пример работы с потоками:
```c
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"

#define LED_GPIO 2  // встроенный светодиод

// Задача вывода текста в консоль (Core 0)
void console_task(void *pvParameters)
{
    int count = 0;
    while (1) {
        printf("Console Task (Core 0): Message %d\n", count++);
        vTaskDelay(pdMS_TO_TICKS(500)); // 500 мс
    }
}

// Задача мигания светодиодом (Core 1)
void led_task(void *pvParameters)
{
    gpio_reset_pin(LED_GPIO);
    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);

    while (1) {
        gpio_set_level(LED_GPIO, 1); // включить LED
        vTaskDelay(pdMS_TO_TICKS(250));
        gpio_set_level(LED_GPIO, 0); // выключить LED
        vTaskDelay(pdMS_TO_TICKS(250));
    }
}

void app_main(void)
{
    // Создаем задачу для консоли на Core 0
    xTaskCreatePinnedToCore(console_task, "Console Task", 2048, NULL, 5, NULL, 0);

    // Создаем задачу для LED на Core 1
    xTaskCreatePinnedToCore(led_task, "LED Task", 1024, NULL, 5, NULL, 1);
}

```
>[!TIP]
>1. Необходимо создать устройство и разработать программу для него, которая будет раз в секунду измерять температуру и влажность воздуха на фармацевтическом складе и печатать полученные значения в консоль.
>2. Чтобы сразу было видно, что устройство работает, оно должно мигать светодиодом с темпом получения измерений.
>3. При выходе значений за пределы допустимых значений, должен подаваться сигнал – печать соответствующего сообщения в консоль, и неспешное мигание светодиода должно смениться очень быстрым (тревожным), чтобы сразу стало ясно – что-то происходит! При этом работа программы ни в коем случае не должна прерываться, то есть по-прежнему должны происходить измерения параметров и печать их значений в консоль.
>4. Можно предусмотреть повторный вывод предупреждающего сообщения в консоль. Скажем, если пользователь по каким-то причинам не увидел текстовое сообщение, а среагировал только на тревожное "моргание" светодиода, то из-за отображения результатов текущих измерений ему будет достаточно сложно найти, что именно произошло. Поэтому было бы неплохо предоставить пользователю возможность по запросу вновь получить текст тревожного сообщения.
>5. Измерения и управление светодиодом должно осуществляться в разных задачах.


 TODO: нет картинок (https://www.freertos.org/Documentation/01-FreeRTOS-quick-start/01-Beginners-guide/01-RTOS-fundamentals) и нет реального кода + форматирование блоков (NOTE, WARNING)
  <!--
 # Контроль температуры и влажности на фармацевтическом складе

## Цель устройства

Создать устройство и программу, которая:

1. Раз в секунду измеряет температуру и влажность воздуха на складе.
2. Выводит полученные значения в консоль.
3. Мигает светодиодом с частотой получения измерений, чтобы было сразу видно, что устройство работает.
4. При выходе значений за допустимые пределы:
   - Выводит в консоль предупреждающее сообщение.
   - Меняет частоту мигания светодиода на быстрый (тревожный), чтобы сразу было понятно, что произошло событие.
5. Продолжает работу без прерывания:
   - Измерения и вывод в консоль продолжаются даже при тревожном сигнале.
6. Предоставляет возможность пользователю по запросу повторно вывести предупреждающее сообщение, если оно было пропущено среди текущих измерений.

## Архитектура программы

- **Задача измерений (TaskMeasurement)**:
  - Снимает показания температуры и влажности раз в секунду.
  - Проверяет значения на соответствие допустимым пределам.
  - Устанавливает тревожный флаг при превышении допустимых значений.

- **Задача управления светодиодом (TaskLED)**:
  - Мигание светодиода с нормальной частотой при нормальных показаниях.
  - Быстрое мигание при тревожном состоянии.

- **Задача обработки тревожных событий (TaskAlert)**:
  - Выводит предупреждающее сообщение в консоль.
  - Позволяет повторный вывод сообщения по запросу пользователя.

- **Коммуникация между задачами**:
  - Используется очередь или общая структура состояния для передачи данных о температуре, влажности и тревожном флаге.

## Требования к устройству

- Микроконтроллер с поддержкой RTOS (например, STM32, ESP32, Arduino с FreeRTOS)
- Датчик температуры и влажности (DHT22, BME280 или аналог)
- Светодиод для индикации состояния
- Консоль для вывода информации

 -->
