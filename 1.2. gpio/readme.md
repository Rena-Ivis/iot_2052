# 1.2 Лабораторная работа: входы и выходы микроконтроллера
## 1.2.1 Управление внешними светодиодами
### Цели работы
Научиться подключать модули (светодиоды: светофор - 3 светодиода и rgb светодиод) к плате ESP32. Научиться работать с ШИМ.

### 1.2.1.1. Светофор

В некоторых случаях одного светодиода на плате может оказаться мало. Допустим, мы хотим реализовать простой индикатор, имитирующий цвета светофора:  

- **Зелёный** – всё в порядке.  
- **Жёлтый** – какой-то параметр (например, измеряемая температура) приблизился к критическому значению и нужно предпринять шаги по нейтрализации надвигающейся угрозы.  
- **Красный** – критическая ситуация, требующая немедленного реагирования.  

В этом случае понадобится **три порта GPIO**, работающих на выход, к каждому из которых будет подключен светодиод.  

> ⚠️ Каждый светодиод должен подключаться через **токоограничивающий резистор**.  
> Необходимо учитывать максимальный ток выхода GPIO. Для большинства микроконтроллеров типовое максимальное значение тока составляет 20 мА (у ESP32 реальное значение выше).  
> Ток светодиода (`Iled`) обычно находится в диапазоне 2…20 мА.  

---

## Расчёт резистора для светодиода

Используем закон Ома:

R = (Uпит - Uled) / Iled
Где:  
- `Uпит = 3.3 В` — напряжение питания микроконтроллера  
- `Uled = 1.8…2.2 В` — прямое падение напряжения на светодиоде (берём среднее 2 В)  
- `Iled` — ток светодиода  

### Минимальное и максимальное сопротивление

- Для тока 20 мА:
  Rmin = (3.3 - 2.0) / 0.020 ≈ 65 Ом

- Для тока 2 мА:
  Rmax = (3.3 - 2.0) / 0.002 ≈ 650 Ом
  
Таким образом можем выбрать любое значение резисторов из диапазона 65…650 Ом. 
**Принципиальная схема**
![image](img/leds_diagram.png)
**Размещение на макетной плате**
![image](img/bb_3leds_mcu.png)

Если же мы используем какой-либо модуль, то они уже содержат токоограничивающий резистор (и дополнительный транзисторный ключ), так что их можно подключать напрямую. Для нашей задачи это могло бы выглядеть так.
![image](img/lights.jpg)

Каждый порт GPIO, подключенный к светодиодам, можно было бы настроить (как в предыдущей программе) по-отдельности функцией gpio_set_direction(), но сделаем на этот раз по-другому. API ESP-IDF содержит функцию gpio_config(), которой нужно передать заполненную структуру gpio_config_t, в которой и укажем нужные порты GPIO и направление их работы.

Сама структура описана в файле driver\gpio.h следующим образом:
```c
typedef struct {
    uint64_t pin_bit_mask;
    gpio_mode_t mode;
    gpio_pullup_t pull_up_en;
    gpio_pulldown_t pull_down_en;
    gpio_int_type_t intr_type;
} gpio_config_t;
```
В этой структуре:
- `pin_bit_mask` – маска конфигурируемых портов GPIO  
- `mode` – режим работы (аналогично аргументу функции `gpio_set_direction()`)  
- `pull_up_en` – включение подтяжки Pull-Up  
- `pull_down_en` – включение подтяжки Pull-Down  
- `intr_type` – управление прерываниями

Программа, в которой будем управлять несколькими светодиодами будет следующая:

```c
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"

// пины подключения светодиодов
#define     LED_RED     33
#define     LED_YELLOW  25
#define     LED_GREEN   26
#define     GPIO_PINS   ((1ULL << LED_RED) | (1ULL << LED_YELLOW) | (1ULL << LED_GREEN))

void app_main(void)
{
    // объявление структуры конфигурации
    gpio_config_t io_conf = {};

    // задание необходимых свойств
    io_conf.pin_bit_mask = GPIO_PINS;             // порты
    io_conf.mode = GPIO_MODE_OUTPUT;              // режим работы - выход
    io_conf.pull_up_en = GPIO_PULLUP_DISABLE;     // нет подтягивающего резистора
    io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE; // нет стягивающего резистора
    io_conf.intr_type = GPIO_INTR_DISABLE;        // прерывания отключены

    // установка конфигурации портов
    gpio_config(&io_conf);

    // счетчик итераций
    uint8_t ticks = 0;

    while (1)
    {
        switch(++ticks % 8)
        {
            case 0:
                gpio_set_level(LED_RED, 0);
                gpio_set_level(LED_YELLOW, 0);
                gpio_set_level(LED_GREEN, 0);
                break;
            case 1:
                gpio_set_level(LED_RED, 1);
                break;
            case 2:
                gpio_set_level(LED_YELLOW, 1);
                break;
            case 3:
                gpio_set_level(LED_RED, 0);
                break;
            case 4:
                gpio_set_level(LED_GREEN, 1);
                break;
            case 5:
                gpio_set_level(LED_YELLOW, 0);
                break;
            case 6:
                gpio_set_level(LED_RED, 1);
                break;
            case 7:
                gpio_set_level(LED_GREEN, 0);
                break;
        }
        vTaskDelay(200 / portTICK_PERIOD_MS);
    }
}
```
> [!TIP]
> **Задания**
>
> 1. Измените схему подключения и код программы так, чтобы они соответствовали вашему подключению модуля к плате.
> 2. В представленной программе один из светодиодов мигает не так, как остальные.  
>    Устраните это нарушение или реализуйте переключение по типу светофора.

### 1.2.1.2. Радуга
Прежде, чем приступать к "Радуге", разберем **ШИМ**

Широтно-импульсная модуляция, сокращенно ШИМ (англ. Pulse Width Modulation, PWM), является одним из наиболее распространенных методов управления мощностью в электронных системах. Этот метод позволяет регулировать мощность, подаваемую на нагрузку, путем изменения ширины импульсов постоянного тока. Широко используется в различных областях электроники, таких как управление двигателями, источники питания, освещение и многие другие устройства.

Основой принципа работы ШИМ является изменение длительности импульсов при постоянной частоте следования этих импульсов. Импульсы представляют собой прямоугольные волны, у которых длительность высокого уровня (включенного состояния) варьируется относительно общего периода сигнала.

ШИМ имеет три основных параметра: частоту, период и коэффициент заполнения. Частота ШИМ (измеряется в герцах) – это число раз, когда ШИМ-сигнал переходит с высокого уровня на низкий и обратно в течение одной секунды. Период ШИМ является величиной, обратной частоте ШИМ. 
![image](img/lights.jpg)

Соотношение времени включения (`Ton`) к общему периоду (`T`), выраженное в процентах, называется **коэффициентом заполнения (Duty Cycle)** и может варьироваться от 0% до 100%:

D = (Ton / T) * 100%

В электронике для прямоугольных импульсов с переменной шириной чаще употребляется величина, обратная коэффициенту заполнения, называемая **скважностью**

S = T / Ton

Соответственно, коэффициент заполнения 50 % эквивалентен скважности, равной 2, 100 % – скважности, равной единице, а 0 % равносилен скважности, равной бесконечности (что имеет вполне логичную физическую интерпретацию, как полное отсутствие импульсов).

Если использовать ШИМ для управления светодиодом, то при низкой частоте ШИМ, например 0,5 Гц и коэффициенте заполнения 50 % (светодиод включается на 1 секунду, а затем выключается на 1 секунду) светодиод будет мигать. При увеличении частоты (уменьшении периода) будет достигнут критический порог, при котором человеческий глаз не сможет воспринимать мигание светодиода и будет казаться, что он горит в половину своей максимальной яркости. При изменении коэффициента заполнения будет меняться и яркость, так как будет меняться среднее напряжение, подводимое к светодиоду.
![image](img/lights.jpg)
Среднее напряжение напрямую связано с коэффициентом заполнения ШИМ

Uсредн = UH * (D / 100%) + UL * (1 - D / 100%)
Где:  
- `UH` — напряжение в состоянии «включено»  
- `UL` — напряжение в состоянии «выключено»  
- `D` — коэффициент заполнения (%)
В ESP32 есть два периферийных устройства ШИМ: светодиодный ШИМ-контроллер (LEDC – LED Controller) и периферийное устройство управления двигателями на основе широтно-импульсной модуляции (MCPWM).

Основная цель светодиодного ШИМ-контроллера (как не трудно догадаться из названия) – управление яркостью светодиодов, хотя его также можно использовать для генерации ШИМ-сигналов и для других целей, например, для генерации звука. 

В ESP32 LEDC имеет две группы каналов (по 8 в каждой). Одна группа каналов работает в высокоскоростном режиме (high speed mode) и реализуется аппаратно. В этой группе каналов возможно автоматическое и постепенное увеличение или уменьшение скважности ШИМ, что позволяет управлять освещением без непосредственного задействования процессора. Другая группа каналов работает в низкоскоростном режиме (low speed mode). В этом режиме скважность ШИМ меняется программным драйвером. Каждая группа каналов может использовать разные источники тактирования ШИМ.

Настройка любого канала LEDC (как в высокоскоростном, так и низкоскоростном режиме) включает три шага:

1. Настройка таймера, путем указания частоты ШИМ-сигнала и разрешающей способности изменения его скважности.
2. Настройка канала путем связывания его с таймером и ножкой GPIO, на которую выводится ШИМ-сигнал. 
3. Настройка выходного сигнала ШИМ.

Настройка таймера осуществляется посредством вызова функции ledc_timer_config(), в которую необходимо передать заполненную структуру ledc_timer_config_t со следующими параметрами:

 - скоростной режим;
 - номер таймера;
 - источник тактирования;
 - частота ШИМ;
 - разрешающая способность коэффициента заполнения ШИМ.

\[
R = \frac{U_\text{пит} - U_\text{LED}}{I_\text{LED}}
\]

Где:  
- \(U_\text{пит} = 3.3\text{ В}\) – напряжение питания микроконтроллера,  
- \(U_\text{LED} = 1.8…2.2\text{ В}\) – прямое падение напряжения на светодиоде (берём среднее 2 В),  
- \(I_\text{LED}\) – ток светодиода.


Вооружается законом Ома

𝑅=𝑈ПИТ−𝑈𝐿𝐸𝐷𝐼𝐿𝐸𝐷
.

Вспоминаем о напряжении питания (𝑈ПИТ
) микроконтроллера в 3.3 В, о том, что прямое падение напряжения на светодиоде (𝑈𝐿𝐸𝐷
) составляет 1.8…2.2 В (конкретное значение тоже можно узнать в справочнике, но возьмем среднее – 2 В). Падением напряжения на p-n переходе открытого транзистора в составе GPIO можем пренебречь. В итоге для тока 20 мА получим сопротивление

𝑅𝑚𝑖𝑛=(3.3−2.0)В0.020А=65
 Ом,

а для тока 2 мА

𝑅𝑚𝑎𝑥=(3.3−2.0)В0.002А=650
 Ом.

Так что можем выбрать любое значение резисторов из диапазона 65…650 Ом. В нашем наборе как раз есть резисторы по 220 Ом, и при их установке ток будет порядка

𝐼=(3.3−2.0)В220Ом≈6
 мА.

Сами светодиоды подключим к GPIO33, GPIO25 и GPIO26. Принципиальная схема такого устройства приведена на рисунке.

Принципиальная схема подключения

Вариант размещения элементов на макетной плате при использовании отдельных компонентов может быть таким.

Макетная плата со светодиодами

Если же мы используем какой-либо модуль, например, как в нашем учебном наборе от Амперки, то они уже содержат токоограничивающий резистор (и дополнительный транзисторный ключ), так что их можно подключать напрямую. Для нашей задачи это могло бы выглядеть так.

Макетная плата с модулями Амперки

То есть, в этом случае макетная плата используется только для распределения питания, и на каждом светодиодном модуле контакты G соединены с землей (контакт GND) микроконтроллера, V подключены к Vin платы ESP32, а S – к портам ввода-вывода (каждый светодиодный модуль к своему порту – GPIO_33, GPIO_25, GPIO_26).


## 1.2.1 Управление внешним устройством на примере реле
### Цели работы
Научиться подключать модули(кнопка) через плату-переходник,подключённую к плате STM32Nucleo.Научиться работать с ШИМ и встроенными параметрами платы.

Эта работа будет происходить с GPIO (General Purpose Input/Output — порты ввода-вывода общего назначения). GPIO позволяют соединять микроконтроллер с внешними устройствами по максимально простому интерфейсу: наличие либо отсутствие сигнала.

Задача: пощелкать не встроенным светодиодом, а внешним реле, подключенным к плате.
Для этого задания понадобятся:

* Плата STM32Nucleo

![image](img/image.png)

* Плата-переходник Grove Base Shield

<img src="img/shield.png" width="200">

* Модуль реле от Grove

<img src="img/rele.jpg" width="200">

У микроконтроллера на учебной отладочной плате есть достаточно много свободных выводов.Свободные выводы можно конфигурировать и использовать как:

* выходы (отправлять на них “высокий” или “низкий” логический уровень, то есть устанавливать напряжение 3,3 В или сбрасывать в ноль)
* входы (считывать их состояние)

Важное пояснение: не все выводы можно задействовать. К примеру, выводы D0 и D1 задействовать не рекомендуется, так как они уже заняты отладочной консолью. D0, D1 и так далее пронумерованы так только на самой плате (маленькие номера у каждого вывода). Выводы же с точки зрения микроконтроллера называются иначе - они сгруппированы в порты (PORT, или просто P), и в рамках каждого порта пронумерованы (например, PA_6, на плате этот вывод подписан как 12).

![scheme](img/scheme.png)


Подключение реле будет через плату-переходник Grove Base Shield,через порт D6.
```C++
#include "mbed.h"
DigitalOut relay(D6);
int on = 1,off = 0;
int main()
{
 
    while(1) {
        relay = on;
        wait(1);
        relay = off;
        wait(1);
    }
}
```
## 1.2.2 Считывание нажатия кнопки

Для этого задания понадобятся:

* Плата STM32Nucleo

![image](img/image.png)

Далее предоставлен пример кода,который позволяет считать нажатие кнопки. Для него понадобится только плата Nucleo, а считывать нажатие будет происходить у встроенной в плату синей кнопки(USER_BUTTON).
```C
#include "mbed.h"
 
DigitalIn mybutton(USER_BUTTON);
DigitalOut myled(LED1);

int main()
{
    mybutton.mode(PullUp);

    while(1) {
        printf("Button state is: %d\n\r", mybutton.read());

        if (mybutton == 0) { // Button is pressed

            myled = !myled; // Toggle the LED state
            wait_ms(200); // 200 ms
        }
    }
}
```


## 1.2.3 Выдача ШИМ-сигнала с платы

Для управления яркостью светодиода будет использоваться широтно-импульсная модуляция(ШИМ). Это означает, что вместо непрерывной подачи напряжения это происходит с перерывами, за счет чего общая яркость свечения будет ниже. Перерывов человеческий глаз не заметит, поскольку будет очень большая скорость переключения.

Для этого задания понадобится:

* Плата STM32Nucleo

![image](img/image.png)

В mbed всё, что касается ШИМ, инкапсулировано в библиотеке PwmOut.
Пример кода:
```C
#include "mbed.h"

PwmOut PWM1(LED1);

int main()
{
    PWM1.period(0.010); // set PWM period to 10 ms
    PWM1=0.5; // set duty cycle to 50%
}
```

Пример для управления яркостью светодиода с клавиатуры:

```C
#include "mbed.h"

PwmOut led(LED1);
float brightness=0.0;

int main()
{
    printf("Control of LED dimmer by host terminal\n\r");
    printf("Press 'u' = brighter, 'd' = dimmer\n\r");

    while(1) {
        char c = getc();
        wait(0.001);
        if((c == 'u') && (brightness < 0.1)) {
            brightness += 0.001;
            led = brightness;
        }

        if((c == 'd') && (brightness > 0.0)) {
            brightness -= 0.001;
            led = brightness;
        }
        printf("%c %1.3f \n \r",c,brightness);
    }
}
```


## 1.2.4 Подключение кнопки
Для этого задания понадобится:

* Плата STM32Nucleo

![image](img/image.png)

* Плата-переходник Grove Shield

<img src="img/shield.png" width="200">

* Кнопочный модуль от Grove

<img src="img/button.jpg" width="200">

Для выполнения задания Кейса понадобится клавиатурный модуль. Он устроен чрезвычайно просто, и подойдет от любого производителя.


Работа с этим модулем совершенно аналогична работе с одной кнопкой, за одним исключением: в модуль уже впаяны подтягивающие резисторы, поэтому включать их в коде явным образом не нужно.Создаётся режим PullNone, чтобы это обозначить и не задействовать встроенный подтягивающий резистор.

Пример считывания нажатия кнопки на порте D7.
```C
#include "mbed.h"

DigitalIn mybutton(D7);
DigitalOut myled(LED1);

int main() {

  mybutton.mode(PullNone);

  while(1) {

    printf("Button state is: %d\n\r", mybutton.read());

    if (mybutton == 0) { // Button is pressed

      myled = !myled; // Toggle the LED state
      wait(0.2); // 200 ms
    }
  }
}
```
